Okay, let's take a quick tour of visualization libraries available in Rust. I'll focus on giving you a sense of the landscape and expected complexity, rather than diving into specific implementation details.

Rust Visualization Libraries

Rust's visualization ecosystem is still evolving compared to Python or JavaScript, but there are some promising options, often with a focus on performance and correctness. Here are a few examples:

Plotters:

Type: A versatile, low-level plotting library.

Description: plotters allows you to draw all kinds of charts and graphs directly on a drawing backend like a raster image or an SVG. It's very flexible but requires you to build the plot from the ground up.

Complexity: Moderate-to-high. Requires manual calculation of coordinate systems and plot elements.

Usage Scenario: Good for applications where you need very specific plot customizations or want to generate raster images or SVG files on the server. It can be combined with a web server to stream plots to clients.

Pros: High flexibility, can work with multiple backends, very low level control.

Cons: Requires manual management of the plot area and the drawing system.

Piston:

Type: A game engine and graphics framework.

Description: Although piston is more than just a visualization library, it provides the necessary tools for graphics rendering, which can be used for plotting data.

Complexity: Moderate-to-high, since you are using a game engine.

Usage Scenario: Good when you need to create visualizations that are also interactive games, or when you need low-level control of the rendering process.

Pros: Extremely flexible and powerful, good for games and interactive visualizations

Cons: Requires you to learn its game engine API, which can be overkill for a simple chart.

Conrod:

Type: A UI toolkit that supports 2D graphics

Description: Similar to piston, but it has more UI-specific features. It also has drawing APIs for creating and updating graphics.

Complexity: Moderate, since you are using a UI toolkit.

Usage Scenario: Good for building application UI or interactive dashboards that need to be run natively.

Pros: UI focused, good for applications that need more elements that charts.

Cons: Is not the best fit if you just want a single chart.

Vulkano:

Type: A low level Vulkan wrapper.

Description: vulkano is a wrapper around the Vulkan API. It's not directly a visualization library, but it provides access to very high-performance GPU-accelerated graphics.

Complexity: High - the API is very low level.

Usage Scenario: When performance is paramount, and you need very specific graphics configurations.

Pros: Very high performance, very flexible, uses the GPU for drawing.

Cons: Very complex to learn and use.

Plotly (bindings):

Type: Plotly (JavaScript visualization library) Bindings.

Description: It uses a rust interface to access the Plotly library, that renders on a webview or using a web server.

Complexity: Low to Moderate.

Usage Scenario: If you need plots similar to the ones rendered by Plotly (and can run a web server, or a webview)

Pros: Easy to use if you are familiar with Plotly in Python or Javascript.

Cons: It does not draw to a canvas element, and it requires a webview or a web server.

Ggez:

Type: A 2D game framework.

Description: ggez is a 2D game framework, which can be used for drawing shapes and lines on a canvas.

Complexity: Moderate, since you are using a game framework.

Usage Scenario: Good for 2D games and simple visualizations.

Pros: Easy to use, good for simple 2D graphics.

Cons: Limited when compared to a full-fledged visualization library.

Expected Complexity:

Low-Level Libraries (Plotters, Vulkano):

Require a significant understanding of drawing and graphics primitives.

Give you fine-grained control but demand more work.

UI Toolkits (Conrod, Piston, Ggez)

Are useful for application UI, but they might be overkill for a simple chart.

Bindings (Plotly):

Make it easier to use a library designed for visualizations.

Complexity Considerations

Wasm Integration: If you want to use these libraries from Wasm, you'll also need to consider Wasm compatibility and any bridging logic.

Real-time Rendering: If you need real-time updates, you'll have to pay attention to performance and efficient data transfer between your code (wasm) and the rendering part (either a canvas or a webview).

For your Sparkline Project:

If you need to draw directly to canvas in a high-performance way, Plotters might be suitable, but it will require you to manage everything yourself.

If you are OK with rendering on an HTML element instead of canvas, then Plotly can simplify your work, as you can rely on their plots.

Next Steps (If you want to explore one):

Explore a Library's Documentation: Pick a library that seems most aligned with your goals and check their documentation and examples.

Start Simple: Begin with very basic examples to understand how to set up and draw simple things, such as shapes, lines, and points.

Incrementally Add Features: Add more features gradually.

I hope this gives you a good starting point! Let me know if you have more questions.